El problema no está en la lógica de “disminuir segundos/minutos” (que en efecto está bien en tu `updateTimer`), sino en que nunca estás disparando ese método cada segundo. En tu store sólo defines:

```ts
startTimer: () => {
  const state = get();
  const timerMinutes = state.settings?.pomodoroMinutes || 25;
  set({ timer: { minutes: timerMinutes, seconds: 0, isRunning: true, isPomodoro: true } });
},
updateTimer: () => {
  set(state => {
    if (!state.timer.isRunning) return state;
    if (state.timer.seconds === 0) {
      if (state.timer.minutes === 0) {
        // Timer finished
        return { ...state, timer: { ...state.timer, isRunning: false } };
      }
      return {
        ...state,
        timer: {
          ...state.timer,
          minutes: state.timer.minutes - 1,
          seconds: 59,
        }
      };
    } else {
      return {
        ...state,
        timer: {
          ...state.timer,
          seconds: state.timer.seconds - 1,
        }
      };
    }
  });
},
pauseTimer: () => { … },
resetTimer: (minutes?) => { … },
```

pero no hay ningún `setInterval` o mecanismo equivalente que llame a `updateTimer()` cada 1000 ms. Por eso, una vez que pones `isRunning: true`, tu store “ve” que el timer está arrancado, pero nadie le dice que disminuya el contador segundo a segundo.

---

## ¿Cómo solucionarlo?

Tienes dos opciones principales:

1. **Inyectar el `setInterval` dentro de la acción `startTimer`**

   ```ts
   let intervalId: number | null = null;

   startTimer: () => {
     if (intervalId) return;               // si ya está corriendo, no hacemos nada
     const state = get();
     const timerMinutes = state.settings?.pomodoroMinutes || 25;
     set({ timer: { minutes: timerMinutes, seconds: 0, isRunning: true, isPomodoro: true } });
     intervalId = window.setInterval(() => {
       get().updateTimer();
     }, 1000);
   },
   pauseTimer: () => {
     if (intervalId) {
       clearInterval(intervalId);
       intervalId = null;
     }
     set(state => ({ timer: { ...state.timer, isRunning: false } }));
   },
   resetTimer: (minutes?) => {
     if (intervalId) {
       clearInterval(intervalId);
       intervalId = null;
     }
     const min = minutes ?? get().settings?.pomodoroMinutes ?? 25;
     set({ timer: { minutes: min, seconds: 0, isRunning: false, isPomodoro: true } });
   },
   ```

2. **Manejar el `setInterval` desde tu componente React con un `useEffect`**

   ```tsx
   const { timer: { isRunning }, updateTimer, pauseTimer } = useAppStore();

   useEffect(() => {
     if (!isRunning) return;
     const id = window.setInterval(updateTimer, 1000);
     return () => window.clearInterval(id);
   }, [isRunning, updateTimer]);

   // Y en el botón “Pausa”:
   <button onClick={pauseTimer}>Pausa</button>
   ```

En ambos casos, lo clave es **llamar** a `updateTimer()` cada segundo. Sin ese loop, el estado `timer.seconds` nunca cambiará y por eso “no se decrementa” en pantalla.
